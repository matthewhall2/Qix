Index: src/Display.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.awt.*;\r\nimport java.awt.event.*;\r\nimport javax.swing.*;\r\nimport javax.swing.Timer;\r\nimport java.awt.geom.*; // For Ellipse2D, etc.\r\nimport java.awt.image.BufferStrategy;\r\nimport java.awt.image.BufferedImage;\r\nimport java.util.*;\r\nimport org.jgrapht.*;\r\nimport org.jgrapht.alg.cycle.CycleDetector;\r\nimport org.jgrapht.graph.DefaultEdge;\r\nimport org.jgrapht.graph.DefaultUndirectedWeightedGraph;\r\nimport org.jgrapht.graph.DefaultWeightedEdge;\r\n\r\npublic class Display  extends JFrame implements ActionListener, KeyListener {\r\n\r\n    private GameDrawCanvas canvas;\r\n    private GameInfoDrawCanvas infoDrawCanvas;\r\n    public final int frameWidth = 750;\r\n    public final int frameHeight = 600;\r\n    Robot myRobot;\r\n\r\n    int length = 0;\r\n    boolean backDraw = false;\r\n    int playerRadius =5;\r\n    int playerX = 300;\r\n    int playerY = 580;\r\n\r\n    int startPathX = playerX;\r\n    int startPathY = playerY;\r\n\r\n    int startX = 20;\r\n    int startY = 20;\r\n\r\n    int playerXSpeed = 0;\r\n    int playerYSpeed = 0;\r\n\r\n    int trueX = playerX - startX;\r\n    int trueY = playerY - startY;\r\n\r\n    int drawSpeed = 2;\r\n\r\n    int fastSpeed = 4;\r\n    int slowSpeed = 2;\r\n\r\n    int[][] Board;\r\n    boolean moveOff = false;\r\n    boolean lastMoveOff = false;\r\n\r\n    boolean isUpPressed = false;\r\n    boolean isDownPressed = false;\r\n    boolean isLeftPressed = false;\r\n    boolean isRightPressed = false;\r\n\r\n    ArrayList<Integer> direction = new ArrayList<>(0);\r\n    ArrayList<Integer> slowOrFast = new ArrayList<Integer>(0);\r\n\r\n    boolean isFastPressed = false;\r\n    boolean isSlowPressed = false;\r\n\r\n    int lastDirection = 0;\r\n\r\n    ArrayList<Integer> currentPathLineListX = new ArrayList<>();\r\n    ArrayList<Integer> currentPathLineListY = new ArrayList<>();\r\n    boolean clearPath = false;\r\n\r\n    ArrayList<ArrayList<Integer>> permanentPathLineListX = new ArrayList<>();\r\n    ArrayList<ArrayList<Integer>> permanentPathLineListY = new ArrayList<>();\r\n\r\n    ArrayList<Polygon> polygonList = new ArrayList<>();\r\n    int startPathDirection = 0;\r\n    int endPathDirection = 0;\r\n\r\n\r\n    class GameDrawCanvas extends JPanel {\r\n        //painting method\r\n        BufferedImage bufferImage;\r\n        BufferStrategy bs;\r\n        Robot myRobot;\r\n        public GameDrawCanvas() throws AWTException {\r\n            Display.this.createBufferStrategy(1);\r\n           // myRobot = new Robot();\r\n\r\n           // this.bufferImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);\r\n        }\r\n        public void paintComponent(Graphics g) {\r\n\r\n            super.paintComponent(g);\r\n           // System.out.println(canvas.getLocationOnScreen());\r\n            //Point p = canvas.getLocationOnScreen();\r\n            //int x = p.x;\r\n            //int y = p.y;\r\n\r\n            Graphics2D g2d = (Graphics2D)g;\r\n            //System.out.println(myRobot.getPixelColor(x + playerX, y + playerY));\r\n            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\r\n                    RenderingHints.VALUE_ANTIALIAS_ON);\r\n            drawPolygons(g2d, Color.BLUE);\r\n            g2d.setColor(Color.WHITE);\r\n            drawBackGround(g2d);\r\n            g2d.setColor(Color.WHITE);\r\n            g2d.drawLine(startPathX, startPathY, playerX, playerY);\r\n            drawPath(g2d, currentPathLineListX, currentPathLineListY);\r\n            drawAllPaths(g2d);\r\n\r\n            if(clearPath){\r\n                // System.out.println(\"testing\");\r\n                addToPolyArr();\r\n                //System.out.println(polygonList.size());\r\n                updateBoard();\r\n                permanentPathLineListX.add((ArrayList<Integer>) currentPathLineListX.clone());\r\n                permanentPathLineListY.add((ArrayList<Integer>) currentPathLineListY.clone());\r\n                currentPathLineListX.clear();\r\n                //System.out.println(currentPathLineListX.size());\r\n                currentPathLineListY.clear();\r\n                startPathDirection = 0;\r\n                endPathDirection = 0;\r\n                moveOff = false;\r\n            }\r\n            drawPlayer(g2d);\r\n            Toolkit.getDefaultToolkit().sync();\r\n//            int n = 12;\r\n//            int[] xpoints = new int[]{50, 70, 70, 170,  170, 190,  190,  170, 170,  70, 70, 50};\r\n//\r\n//            int[] ypoints = new int[]{50, 50, 30, 30, 50, 50, 150, 150, 170, 170, 150, 150};\r\n//            Polygon p = new Polygon(xpoints, ypoints, n);\r\n//            g2d.fill(p);\r\n//            g2d.drawImage(bufferImage, 0, 0, this);\r\n//            g2d.dispose();\r\n        }\r\n\r\n        private void drawPolygons(Graphics2D g2d, Color color){\r\n            int i = polygonList.size() - 1;\r\n            //polygonList.get(0);\r\n            while(i >= 0){\r\n                g2d.setColor(color);\r\n                g2d.fill(polygonList.get(i));\r\n                g2d.setColor(Color.WHITE);\r\n                g2d.draw(polygonList.get(i));\r\n\r\n\r\n                i -= 1;\r\n            }\r\n        }\r\n\r\n        private void drawBackGround (Graphics2D g2d){\r\n            g2d.setColor(Color.RED);\r\n            this.setBackground(Color.BLACK);\r\n            g2d.setColor(Color.WHITE);\r\n            g2d.drawLine(startX, startY, frameWidth - startX, startX);\r\n            g2d.drawLine(startX, startY, startX, frameHeight - startY);\r\n            g2d.drawLine(startX, frameHeight - startY, frameWidth - startX, frameHeight - startY);\r\n            g2d.drawLine(frameWidth - startX, startY, frameWidth - startX, frameHeight - startY);\r\n        }\r\n\r\n        private void drawPlayer(Graphics2D g2d){\r\n            g2d.setColor(Color.RED);\r\n            Ellipse2D player = new Ellipse2D.Double(playerX - playerRadius, playerY - playerRadius,\r\n                    2 * playerRadius, 2*playerRadius);\r\n            g2d.setStroke(new BasicStroke(2));\r\n            g2d.draw(player);\r\n            g2d.setStroke(new BasicStroke(1));\r\n        }\r\n\r\n        private void drawPath(Graphics2D g2d, ArrayList<Integer> X, ArrayList<Integer> Y){\r\n            g2d.setColor(Color.WHITE);\r\n            int i = 1;\r\n            while(i < X.size()){\r\n                int x1 = X.get(i - 1);\r\n                int y1 = Y.get(i - 1);\r\n                int x2 = X.get(i);\r\n                int y2= Y.get(i);\r\n                g2d.drawLine(x1, y1, x2, y2);\r\n                i += 1;\r\n            }\r\n        }\r\n\r\n        private void drawAllPaths(Graphics2D g2d){\r\n            int i = 0;\r\n            while(i < permanentPathLineListX.size()){\r\n                drawPath(g2d, permanentPathLineListX.get(i), permanentPathLineListY.get(i));\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    class GameInfoDrawCanvas extends JPanel{\r\n        public void paintComponent(Graphics g) {\r\n            super.paintComponent(g);\r\n            Graphics2D g2d = (Graphics2D) g;\r\n            g2d.setColor(Color.RED);\r\n\r\n            this.setBackground(Color.BLACK);\r\n            g2d.setColor(Color.RED);\r\n            g2d.drawLine(0, 140, frameWidth, 140);\r\n            g2d.setColor(Color.MAGENTA);\r\n            g2d.setFont(new Font(\"TimesRoman\", Font.PLAIN, 20));\r\n\r\n            g2d.drawString(\"QIX\", 50, 50);\r\n\r\n        }\r\n    }\r\n\r\n    private int[][] initBoardArray(int[][] Board){\r\n        for(int i = 0; i < Board.length; i++){\r\n            for(int j = 0; j < Board[i].length; j++){\r\n                if(j == 0 || j == Board[i].length - 1){\r\n                    Board[i][j] = 1;\r\n                }\r\n                if(i == 0 || i == Board.length - 1){\r\n                    Board[i][j] = 1;\r\n                }\r\n            }\r\n        }\r\n        return Board;\r\n    }\r\n\r\n    private int[][] copyBoard(){\r\n        int[][] temp = new int[this.Board.length][this.Board[0].length];\r\n        for(int i = 0; i < Board.length; i++){\r\n            for(int j = 0; j < Board[0].length; j++){\r\n                temp[i][j] = this.Board[i][j];\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    public Display() throws AWTException {\r\n        myRobot = new Robot();\r\n        Board = new int[frameHeight - 2 * startY + 1][frameWidth - 2 * startX + 1];\r\n        initBoardArray(Board);\r\n        canvas = new GameDrawCanvas();\r\n        infoDrawCanvas = new GameInfoDrawCanvas();\r\n        canvas.setPreferredSize(new Dimension(frameWidth, frameHeight));\r\n        infoDrawCanvas.setPreferredSize(new Dimension(frameWidth, 150));\r\n        // Add both panels to this JFrame\r\n        Container cp = getContentPane();\r\n        cp.setLayout(new BorderLayout());\r\n        addKeyListener(this);\r\n        cp.add(canvas, BorderLayout.CENTER);\r\n        cp.add(infoDrawCanvas, BorderLayout.NORTH);\r\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        Timer timer = new Timer(25, this);\r\n        timer.start();\r\n        setTitle(\"Qix\");\r\n        pack();           // pack all the components in the JFrame\r\n        setVisible(true); // show it\r\n        Graph<String, DefaultWeightedEdge> g = new DefaultUndirectedWeightedGraph<String,\r\n                DefaultWeightedEdge>(DefaultWeightedEdge.class);\r\n        CycleDetector<String, DefaultEdge> c;\r\n    }\r\n\r\n    public void putNewEdgeInBoard(int direction, int X, int Y){\r\n        this.Board[Y][X] = 1;\r\n        if(direction == 3) {\r\n            if(X > 0){\r\n                X -= 1;\r\n            }\r\n            while (this.Board[Y][X] != 1) {\r\n                this.Board[Y][X] = 1;\r\n                X -= 1;\r\n            }\r\n        } else if(direction == 1){\r\n            if(X < 710){\r\n                X += 1;\r\n            }\r\n            while (this.Board[Y][X] != 1) {\r\n                this.Board[Y][X] = 1;\r\n                X += 1;\r\n            }\r\n        }else if(direction == 4){\r\n            if(Y > 0){\r\n                Y -= 1;\r\n            }\r\n            while (this.Board[Y][X] != 1) {\r\n                this.Board[Y][X] = 1;\r\n                Y -= 1;\r\n            }\r\n        }else if(direction == 2){\r\n            if(Y < 560){\r\n                Y += 1;\r\n            }\r\n            while (this.Board[Y][X] != 1) {\r\n                this.Board[Y][X] = 1;\r\n                Y += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void addToPolyArr(){\r\n//        ArrayList<Integer> finalPoint = findPolygonCorner();\r\n//        if(finalPoint.size() == 4){\r\n//            int[] X = arrayListToIntArray(currentPathLineListX, 2);\r\n//            int[] Y = arrayListToIntArray(currentPathLineListY, 2);\r\n//            Y[Y.length - 2] = finalPoint.get(1);\r\n//            X[X.length - 2] = finalPoint.get(0);\r\n//            X[X.length - 1] = finalPoint.get(2);\r\n//            Y[Y.length - 1] = finalPoint.get(3);\r\n//            Polygon p = new Polygon(X, Y, X.length);\r\n//            polygonList.add(p);\r\n//        }else if(finalPoint.size() == 2) {\r\n//            int[] X = arrayListToIntArray(currentPathLineListX, 1);\r\n//            int[] Y = arrayListToIntArray(currentPathLineListY, 1);\r\n//            Y[Y.length - 1] = finalPoint.get(1);\r\n//            X[X.length - 1] = finalPoint.get(0);\r\n//            Polygon p = new Polygon(X, Y, X.length);\r\n//            polygonList.add(p);\r\n//        }else{\r\n//            int[] X = arrayListToIntArray(currentPathLineListX, 0);\r\n//            int[] Y = arrayListToIntArray(currentPathLineListY, 0);\r\n//            Polygon p = new Polygon(X, Y, X.length);\r\n//            polygonList.add(p);\r\n//        }\r\n        findPolygonCorner();\r\n        int[] X = arrayListToIntArray(currentPathLineListX);\r\n        int[] Y = arrayListToIntArray(currentPathLineListY);\r\n        Polygon p = new Polygon(X, Y, X.length);\r\n        polygonList.add(p);\r\n\r\n    }\r\n\r\n    public void findPolygonCorner() {\r\n        int[][] directionsToCheckLeft = new int[][]{{0, 1, -1, 0, 0, -1},\r\n                {-1, 0, 0, -1, 1, 0}, {0, -1, 1, 0, 0, 1}, {1, 0, 0, 1, -1, 0}};\r\n        int[][] directionsToCheckRight = new int[][]{{0, -1, -1, 0, 0, 1}, {1, 0, 0, -1, -1, 0}, {0, 1, 1, 0, 0, -1},\r\n                {-1, 0, 0, 1, 1, 0}};\r\n        int[] directionsToCount = new int[]{1, 0, -1, 0, -1, 0, 0, -1};\r\n        ArrayList<Integer> leftX = (ArrayList<Integer>) currentPathLineListX.clone();\r\n        ArrayList<Integer> leftY = (ArrayList<Integer>) currentPathLineListY.clone();\r\n\r\n        ArrayList<Integer> rightX = (ArrayList<Integer>) currentPathLineListX.clone();\r\n        ArrayList<Integer> rightY = (ArrayList<Integer>) currentPathLineListY.clone();\r\n\r\n        ArrayList<Integer> r = new ArrayList<>();\r\n\r\n        findCorners(endPathDirection, directionsToCheckLeft, leftX, leftY);\r\n        findCorners(endPathDirection, directionsToCheckRight, rightX, rightY);\r\n        float left = getAverageLength(leftX, leftY);\r\n        float right = getAverageLength(rightX, rightY);\r\n        System.out.println(left);\r\n        System.out.println(right);\r\n        if(left <= right){\r\n            currentPathLineListX = (ArrayList<Integer>) leftX.clone();\r\n            currentPathLineListY =  (ArrayList<Integer>) leftY.clone();\r\n        }else{\r\n            currentPathLineListX =  (ArrayList<Integer>) rightX.clone();\r\n            currentPathLineListY =  (ArrayList<Integer>) rightY.clone();\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private float getAverageLength(ArrayList<Integer> pathX, ArrayList<Integer> pathY){\r\n        float total = 0;\r\n        for(int i = 1; i < pathX.size(); i++){\r\n            total += Math.sqrt(Math.pow(pathX.get(i) - pathX.get(i - 1), 2) +  Math.pow(pathY.get(i) - pathY.get(i - 1), 2));\r\n        }\r\n        System.out.println(pathX.size());\r\n        System.out.println(total);\r\n        return total / pathX.size();\r\n    }\r\n\r\n    private void findCorners(int direction, int[][] directionArr, ArrayList<Integer> pathX, ArrayList<Integer> pathY){\r\n\r\n        int[] directions = directionArr[direction - 1];\r\n        int counter = 0;\r\n        int oldx = playerX - 20;\r\n        int oldy = playerY - 20;\r\n        int x = 0;\r\n        int y = 0;\r\n        int lastX = pathX.get(0);\r\n        int lastY = pathY.get(0);\r\n        int testCounter = 0;\r\n//        System.out.println(lastY - playerY);\r\n//        System.out.println(lastX - playerX);\r\n        while(oldx + 20 != lastX || oldy + 20 != lastY) {\r\n           testCounter += 1;\r\n            directions = directionArr[direction - 1];\r\n            for (int i = 1; i < 6; i += 2) {\r\n                //System.out.println(y);\r\n                x = oldx + directions[i - 1];\r\n                y = oldy + directions[i];\r\n                if (this.Board[y][x] == 1) {\r\n                    if (i != 3 && counter != 0) {\r\n                        pathX.add(oldx + 20);\r\n                        pathY.add(oldy + 20);\r\n                        //System.out.println(\"test\");\r\n                    }\r\n                    counter += 1;\r\n                    break;\r\n                }\r\n            }\r\n            direction = getNewDirection(x, y, oldx, oldy);\r\n            oldx = x;\r\n            oldy = y;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private int getNewDirection(int newx, int newy, int oldx, int oldy){\r\n        if(newx - oldx == 1 && newy - oldy == 0){\r\n            return 3;\r\n        }else if(newx - oldx == -1){\r\n           return 1;\r\n        }else if(newy - oldy == 1){\r\n            return 4;\r\n        }else {\r\n            return 2;\r\n        }\r\n    }\r\n\r\n    private int[] getDirection(int dir){\r\n        switch (dir){\r\n            case 1:\r\n                return new int[]{-1, 0};\r\n            case 2:\r\n                return new int[]{0, -1};\r\n            case 3:\r\n                return new int[]{1, 0};\r\n            case 4:\r\n                return new int[]{0, 1};\r\n            default:\r\n                return new int[]{0, 0};\r\n        }\r\n    }\r\n\r\n\r\n    public int[] arrayListToIntArray(ArrayList<Integer> lst){\r\n\r\n        int[] r = new int[lst.size()];\r\n        int i = 0;\r\n        while(i < lst.size()){\r\n            r[i] = lst.get(i);\r\n            i += 1;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    @Override\r\n    public void actionPerformed(ActionEvent actionEvent) {\r\n        boolean update = false;\r\n        clearPath = false;\r\n        if(!direction.isEmpty()) {\r\n            // int lastDirectionKey = direction.size() - 1;\r\n            int dir = direction.get(direction.size() - 1);\r\n            int lastSpeedKey = slowOrFast.size() - 1;\r\n            int speed = 2;\r\n            if(lastSpeedKey != -1){\r\n                speed = slowOrFast.get(lastSpeedKey);\r\n            }\r\n            if(!moveOff){\r\n                dir = 0;\r\n            }\r\n\r\n            switch(dir){\r\n                case 1:\r\n                    playerXSpeed = -speed;\r\n                    playerYSpeed = 0;\r\n                    break;\r\n                case 2:\r\n                    playerYSpeed = -speed;\r\n                    playerXSpeed = 0;\r\n                    break;\r\n                case 3:\r\n                    playerXSpeed = speed;\r\n                    playerYSpeed = 0;\r\n                    break;\r\n                case 4:\r\n                    playerYSpeed = speed;\r\n                    playerXSpeed = 0;\r\n\r\n            }\r\n\r\n            playerX += playerXSpeed;\r\n            playerY += playerYSpeed;\r\n            int lastY = trueY;\r\n            int lastX = trueX;\r\n            trueX += playerXSpeed;\r\n            trueY += playerYSpeed;\r\n            boolean moveBack = false;\r\n\r\n            // the following are corrections for going out of bound, or  from moving\r\n            // into the playfield without a button pressed\r\n            if (trueX < 0) {\r\n                trueX = 0;\r\n                playerX = 20;\r\n\r\n            } else if (trueX > 710) {\r\n                trueX = 710;\r\n                playerX = 730;\r\n\r\n            } else if (trueY < 0) {\r\n                trueY = 0;\r\n                playerY = 20;\r\n\r\n            } else if (trueY > 560) {\r\n                trueY = 560;\r\n                playerY = 580;\r\n\r\n            } else if (moveOff) {\r\n                //System.out.println(\"test\");\r\n                if (this.Board[trueY][trueX] > 1) {\r\n                    moveBack = true;\r\n                    while (this.Board[trueY][trueX] > 1) {\r\n                        playerX -= playerXSpeed / 2;\r\n                        playerY -= playerYSpeed / 2;\r\n                        trueX -= playerXSpeed / 2;\r\n                        trueY -= playerYSpeed / 2;\r\n\r\n                    }\r\n                }\r\n//                if (this.Board[lastY][lastX] == 1 && this.Board[trueY][trueX] == 0 || dir != lastDirection) {\r\n//                    clearPath = false;\r\n//                    startPathX = lastX + 20;\r\n//                    startPathY = lastY + 20;\r\n//                    System.out.println(lastX);\r\n//                    System.out.println(lastY);\r\n//                    currentPathLineListX.add(lastX + 20);\r\n//                    currentPathLineListY.add(lastY + 20);\r\n//                    putNewEdgeInBoard(lastDirection, lastX, lastY);\r\n//                }\r\n                if(this.Board[lastY][lastX] == 1 && this.Board[trueY][trueX] > 1){\r\n//                    playerX = lastX + 20;\r\n//                    playerY = lastY + 20;\r\n                    startPathX = playerX;\r\n                    startPathY = playerY;\r\n\r\n                }else if(this.Board[lastY][lastX] == 1 && this.Board[trueY][trueX] == 0 || dir != lastDirection) {\r\n//                    if(this.Board[trueY][trueX] >= 1){\r\n//                        startPathX = lastX + 20;\r\n//                        startPathY = lastY + 20;\r\n//                    }\r\n                    clearPath = false;\r\n                    if(!moveBack && this.Board[trueY][trueX] !=1) {\r\n                        startPathX = lastX + 20;\r\n                        startPathY = lastY + 20;\r\n//                    System.out.println(lastX);\r\n////                    System.out.println(lastY);\r\n                        if(currentPathLineListX.size() == 0){\r\n                            startPathDirection = dir;\r\n                        }\r\n                        currentPathLineListX.add(lastX + 20);\r\n                        currentPathLineListY.add(lastY + 20);\r\n                        if (dir != lastDirection) {\r\n                            putNewEdgeInBoard(lastDirection, lastX, lastY);\r\n\r\n                        } else {\r\n                            putNewEdgeInBoard(lastDirection, playerX, playerY);\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            } else if (!moveOff && this.Board[lastY][lastX] == 1) {\r\n//                playerX = lastX + 20;\r\n//                playerY = lastY + 20;\r\n//                trueX = lastX;\r\n//                trueY = lastY;\r\n//                startPathY = playerY;\r\n//                startPathX = playerX;\r\n                while (this.Board[trueY][trueX] != 1) {\r\n                    playerX -= playerXSpeed / 2;\r\n                    playerY -= playerYSpeed / 2;\r\n\r\n                    trueX -= playerXSpeed / 2;\r\n                    trueY -= playerYSpeed / 2;\r\n                    startPathY = playerY;\r\n                    startPathX = playerX;\r\n                }\r\n            }\r\n\r\n            if(this.Board[trueY][trueX] == 1 && slowOrFast.size() == 0){\r\n                moveOff = false;\r\n                lastMoveOff = false;\r\n                startPathX = playerX;\r\n                startPathY = playerY;\r\n            }\r\n            if(this.Board[trueY][trueX] == 1 && this.currentPathLineListX.size() > 0){\r\n                //System.out.println(\"the fuck\");\r\n                this.currentPathLineListX.add(trueX + 20);\r\n                this.currentPathLineListY.add(trueY + 20);\r\n                startPathX = playerX;\r\n                startPathY = playerY;\r\n                //System.out.println(this.currentPathLineListX.size());\r\n                clearPath = true;\r\n                //moveOff =false;\r\n                update = true;\r\n                putNewEdgeInBoard(dir, trueX, trueY);\r\n                endPathDirection = dir;\r\n                //fillBoardArea();\r\n\r\n                // System.out.println(Arrays.toString(this.Board[trueY]));\r\n//                System.out.println(clearPath);\r\n            }\r\n\r\n            lastDirection = dir;\r\n            repaint();\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private void updateBoard() {\r\n        //System.out.println(polygonList.size());\r\n        Point p = new Point();\r\n\r\n        for (int row = 20; row <= 580; row++) {\r\n            for (int col = 20; col <= 730; col++) {\r\n                p.x = col;\r\n                p.y = row;\r\n                if (this.Board[row - 20][col - 20] != 1) {\r\n                    for(int i = 0; i < polygonList.size(); i++){\r\n                        if(polygonList.get(i).contains(p)){\r\n                            this.Board[row - 20][col - 20] = i + 2;\r\n                        }\r\n                    }\r\n//                    for (Polygon poly : polygonList) {\r\n//                        if (poly.contains(p)) {\r\n//                            this.Board[row - 20][col - 20] = 2;\r\n//                        }\r\n//                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    @Override\r\n    public void keyTyped(KeyEvent keyEvent) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void keyPressed(KeyEvent keyEvent) {\r\n        switch(keyEvent.getKeyCode()) {\r\n            case KeyEvent.VK_UP:\r\n                playerYSpeed = -drawSpeed;\r\n                playerXSpeed = 0;\r\n                if(!isUpPressed){\r\n                    direction.add(2);\r\n                }\r\n                isUpPressed = true;\r\n                break;\r\n            case KeyEvent.VK_DOWN:\r\n                playerYSpeed = drawSpeed;\r\n                playerXSpeed = 0;\r\n                if(!isDownPressed){\r\n                    direction.add(4);\r\n                }\r\n                isDownPressed = true;\r\n                break;\r\n            case KeyEvent.VK_LEFT:\r\n                playerXSpeed = -drawSpeed;\r\n                playerYSpeed = 0;\r\n                if(!isLeftPressed){\r\n                    direction.add(1);\r\n                }\r\n                isLeftPressed = true;\r\n                break;\r\n            case KeyEvent.VK_RIGHT:\r\n                playerXSpeed = drawSpeed;\r\n                playerYSpeed = 0;\r\n                if(!isRightPressed){\r\n                    direction.add(3);\r\n                }\r\n                isRightPressed = true;\r\n                break;\r\n            case KeyEvent.VK_F:\r\n                drawSpeed = fastSpeed;\r\n                if(moveOff){\r\n                    lastMoveOff = true;\r\n                }\r\n                moveOff = true;\r\n//                startPathY = playerY;\r\n//                startPathX = playerX;\r\n                if(!isFastPressed){\r\n                    slowOrFast.add(fastSpeed);\r\n                }\r\n                isFastPressed = true;\r\n                break;\r\n            case KeyEvent.VK_S:\r\n                drawSpeed = slowSpeed;\r\n                if(moveOff){\r\n                    lastMoveOff = true;\r\n                }\r\n//                if(!moveOff) {\r\n//                    startPathY = playerY;\r\n//                    startPathX = playerX;\r\n//                }\r\n                moveOff = true;\r\n\r\n                if(!isSlowPressed){\r\n                    slowOrFast.add(slowSpeed);\r\n                }\r\n                isSlowPressed = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void keyReleased(KeyEvent keyEvent) {\r\n//        System.out.println(this.Board[trueY][trueX]);\r\n//        System.out.println(moveOff);\r\n//        if(this.Board[trueY][trueX] == 1 && slowOrFast.size() == 1) {\r\n//            moveOff = false;\r\n//            System.out.println(moveOff);\r\n//        }\r\n        switch (keyEvent.getKeyCode()){\r\n            case KeyEvent.VK_S:\r\n                isSlowPressed = false;\r\n                slowOrFast.remove((Integer)slowSpeed);\r\n//                if(slowOrFast.size() == 0){\r\n//                    moveOff = false;\r\n//                }\r\n\r\n                break;\r\n            case KeyEvent.VK_F:\r\n                drawSpeed = 2;\r\n                isFastPressed = false;\r\n                //moveOff = false;\r\n                slowOrFast.remove((Integer)fastSpeed);\r\n//                if(slowOrFast.size() == 0){\r\n//                    moveOff = false;\r\n//                }\r\n                break;\r\n            case KeyEvent.VK_DOWN:\r\n                isDownPressed = false;\r\n                direction.remove((Integer)4);\r\n                break;\r\n            case KeyEvent.VK_UP:\r\n                isUpPressed = false;\r\n                direction.remove((Integer)2);\r\n                break;\r\n            case KeyEvent.VK_LEFT:\r\n                isLeftPressed = false;\r\n                direction.remove((Integer)1);\r\n                break;\r\n            case KeyEvent.VK_RIGHT:\r\n                isRightPressed = false;\r\n                direction.remove((Integer)3);\r\n                break;\r\n\r\n        }\r\n    }\r\n\r\n    public static void main(String[]args) throws AWTException {\r\n        //opens the window by creating a new Display class\r\n        Display d = new Display();\r\n\r\n\r\n\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Display.java b/src/Display.java
--- a/src/Display.java	(revision cc74a4a9fbc1cf1440d2f3f0738f11733e820af7)
+++ b/src/Display.java	(date 1617898682777)
@@ -232,7 +232,7 @@
         canvas = new GameDrawCanvas();
         infoDrawCanvas = new GameInfoDrawCanvas();
         canvas.setPreferredSize(new Dimension(frameWidth, frameHeight));
-        infoDrawCanvas.setPreferredSize(new Dimension(frameWidth, 150));
+        infoDrawCanvas.setPreferredSize(new Dimension(frameWidth, 50));
         // Add both panels to this JFrame
         Container cp = getContentPane();
         cp.setLayout(new BorderLayout());
Index: Qix.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Qix.iml b/Qix.iml
--- a/Qix.iml	(revision cc74a4a9fbc1cf1440d2f3f0738f11733e820af7)
+++ b/Qix.iml	(date 1617562901381)
@@ -7,5 +7,6 @@
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="org.jgrapht:jgrapht-core:1.5.1" level="project" />
   </component>
 </module>
\ No newline at end of file
